287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。


分析：

1.排序解法
先把原来的数组进行排序，然后逐个遍历，一旦发现后一个元素和当前的元素相等，那么就返回，这就是我们找到了重复数字。但是这种思想，
就不满足说明里面的，不能改变原数组，虽然时间复杂度是满足O（n^2）。

2.哈希思想
用个哈希集合（HashSet）来记录已经出现过的元素，一旦遍历到了元素曾经出现在集合当中，那么就返回，这就是需要寻找的重复数字。

3.重新排序的思想
这种思想说起来有点复杂，但是时间复杂度是最好的。
我们从头开始遍历数组，遍历到的下标为i，那么我们就分两种情况来讨论：

如果num[i]等于(i+1)，就是值等于刚好等于下标那么就遍历到下一个。因为刚刚好这个就是对应的，我们就不管他了。
如果num[i]和(i+1)不等，那么就去吧下标等于（num[i] - 1）的数字和这个数字进行交换（下标为i），这样再去判断如今的这个位置上的value和index是否相等，如果不等，继续交换。交换到这个位置上的num[i]和(i+1)相等为止；或者你会找到一个数字，这个数字，那个数字在对应的位置上已经有了，那么这个就是重复的那个数字了。

int findDuplicate(vector<int> &nums) {
		int fast = nums[nums[0]];
        int slow = nums[0];//快、慢指针
        
        while (fast != slow)
        { 
            //指针进入环内
            slow = nums[slow];
            fast = nums[nums[fast]];
        }

        slow = 0;
        
        while (fast != slow) 
        {
            //寻找环入口，即重复整数
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;
}

4.用二分思想
这里的思想有点复杂，大概的思想是这样：
我们先假设一个排序好的数组中，你如果取中间的数字，那么如果你的这个中间数是要比当前的索引的坐标大的话，那么就是也就是nums[i] > i，那么就是说明那个重复的数字是在后半部分的，因为只有在后半部分有重复数字存在的时候，才会多出一个数字来，那么我们就用二分法，吧start取到中点位置，继续寻找；反之，那个重复的数字是在前半部的。
因为我们这数组是没排序的数组，那么我们根据上面的那个计数的思想，我们先取一个取值范围，如果数组里面的元素的取值在这个取值范围的元素个数，等于这个取值范围的区间，那么就表示这个取值范围内不存在重复元素，我们要取别的区间的，继续计数。


class Solution {
public:
    int findDuplicate(vector<int> &nums) {
        int len = nums.size();
        int left = 0;
        int right = len - 1;

        while (left <= right) 
		{
            int mid = (left + right) >> 1;
            int counter = 0;
			
			//统计数组中小于中间值的数的个数
            for (int i = 0; i < len;i++) 
			{
                if (nums[i] <= mid) 
				{
                    counter++;
                }
            }

            if (counter > mid) 
			{
                right = mid - 1;//在[left,mid-1]中查找
            } 
			else 
			{
                left = mid + 1;
            }
        }
        return left;
    }
};
